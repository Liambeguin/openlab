commit 22cb9306cb91680e2af6c5beac673f6651051624
Author: Liam BEGUIN <liambeguin@gmail.com>
Date:   Thu Mar 19 22:42:17 2015 -0400

    Added CAN Bus support.

    Signed-off-by: Liam BEGUIN <liambeguin@gmail.com>

diff --git a/appli/tests/drivers/CMakeLists.txt b/appli/tests/drivers/CMakeLists.txt
index 02ebd71..7111064 100644
--- a/appli/tests/drivers/CMakeLists.txt
+++ b/appli/tests/drivers/CMakeLists.txt
@@ -22,8 +22,14 @@ add_executable(test_leds leds)
 target_link_libraries(test_leds platform)

 if("${DRIVERS}" STREQUAL "stm32l1xx" OR "${DRIVERS}" STREQUAL "stm32f1xx" OR "${DRIVERS}" STREQUAL "stm32f4xx")
-add_executable(test_uart uart)
-target_link_libraries(test_uart platform)
+	add_executable(test_uart uart)
+	target_link_libraries(test_uart platform)
+
+	add_executable(test_can_rx can_rx)
+	target_link_libraries(test_can_rx platform)
+
+	add_executable(test_can_tx can_tx)
+	target_link_libraries(test_can_tx platform)
 endif("${DRIVERS}" STREQUAL "stm32l1xx" OR "${DRIVERS}" STREQUAL "stm32f1xx" OR "${DRIVERS}" STREQUAL "stm32f4xx")

 if(${PLATFORM_HAS_BUTTON})
diff --git a/appli/tests/drivers/can_rx.c b/appli/tests/drivers/can_rx.c
new file mode 100644
index 0000000..1013388
--- /dev/null
+++ b/appli/tests/drivers/can_rx.c
@@ -0,0 +1,36 @@
+#include <stdint.h>
+#include "platform.h"
+#include "debug.h"
+#include "uart.h"
+
+#include "can.h"
+
+extern can_t can;
+
+static void can_rx(handler_arg_t arg, uint32_t mailbox, uint16_t id,
+        const uint8_t *data, uint8_t length);
+
+int main()
+{
+    // Initialize the platform
+    platform_init();
+
+    // Configure the CAN
+    can_set_rx_handler(can, can_rx, NULL);
+
+    // Run
+    platform_run();
+    return 0;
+}
+
+static void can_rx(handler_arg_t arg, uint32_t mailbox, uint16_t id,
+        const uint8_t *data, uint8_t length)
+{
+    log_printf("CAN message from %x (%u): ", id, length);
+    uint32_t i;
+    for (i = 0; i < length; i++)
+    {
+        log_printf("%2x ", data[i]);
+    }
+    log_printf("\n");
+}
diff --git a/appli/tests/drivers/can_tx.c b/appli/tests/drivers/can_tx.c
new file mode 100644
index 0000000..8b5b963
--- /dev/null
+++ b/appli/tests/drivers/can_tx.c
@@ -0,0 +1,37 @@
+#include <stdint.h>
+#include <math.h>
+#include "platform.h"
+#include "debug.h"
+#include "uart.h"
+
+#include "can.h"
+
+extern can_t can;
+
+// Task function
+static void tx(handler_arg_t arg);
+
+static soft_timer_t st;
+
+int main()
+{
+    // Initialize the platform
+    platform_init();
+    soft_timer_init();
+
+    soft_timer_set_handler(&st, tx, NULL);
+    soft_timer_start(&st, soft_timer_s_to_ticks(1), 1);
+
+    // Run
+    platform_run();
+    return 0;
+}
+
+static void tx(handler_arg_t arg)
+{
+    static uint8_t data[4] =
+    { 'A', 'B', 'C' };
+    data[3]++;
+    log_printf("sending! %x\n", data[3]);
+    can_transmit(can, 1, 0x123, data, 4);
+}
diff --git a/drivers/CMakeLists.txt b/drivers/CMakeLists.txt
index f2f3147..5d4ecdb 100644
--- a/drivers/CMakeLists.txt
+++ b/drivers/CMakeLists.txt
@@ -28,6 +28,7 @@ if("${DRIVERS}" STREQUAL "stm32l1xx")
 		stm32/spi
 		stm32/i2c
 		stm32/uart
+		stm32/can
 		stm32/timer
 		stm32/dac
 		stm32/dma
@@ -60,6 +61,7 @@ elseif("${DRIVERS}" STREQUAL "stm32f1xx")
 		stm32/spi
 		stm32/i2c
 		stm32/uart
+		stm32/can
 		stm32/timer
 		stm32/dma
 		stm32/unique_id
@@ -79,7 +81,7 @@ elseif("${DRIVERS}" STREQUAL "stm32f1xx")
 		stm32f1xx/rtc
 		stm32f1xx/stm32f1xx
 	)
-
+
 elseif("${DRIVERS}" STREQUAL "stm32f4xx")
 	include_directories(cortex-m3)
 	include_directories(stm32)
@@ -89,6 +91,7 @@ elseif("${DRIVERS}" STREQUAL "stm32f4xx")
 		cortex-m3/boot
 		cortex-m3/nvic
 		stm32/uart
+		stm32/can
 		stm32/timer
 		stm32/spi
 		stm32/i2c
@@ -109,10 +112,10 @@ elseif("${DRIVERS}" STREQUAL "stm32f4xx")
 		stm32f4xx/ethmac_descriptors
 		stm32f4xx/stm32f4xx
 	)
-
+
  elseif("${DRIVERS}" STREQUAL "native")
  	include_directories(native)
-
+
  	add_library(drivers_native STATIC
 		native/timer
 		native/timer
diff --git a/drivers/can.h b/drivers/can.h
new file mode 100644
index 0000000..c1adb35
--- /dev/null
+++ b/drivers/can.h
@@ -0,0 +1,39 @@
+/*
+ * can.h
+ *
+ *  Created on: Dec 18, 2011
+ *      Author: clem
+ */
+
+#ifndef CAN_H_
+#define CAN_H_
+
+#include <stdint.h>
+#include "handler.h"
+
+typedef const void* can_t;
+
+typedef enum
+{
+    CAN_OK = 0,
+    CAN_ERR_TX_FAILED = 1,
+    CAN_ERR_TX_MAILBOX_FULL = 2,
+    CAN_ERR_TOO_BIG = 3,
+    CAN_ERR_TX_INVALID_MAILBOX = 4,
+} can_status_t;
+
+typedef void (*can_tx_handler_t)(handler_arg_t arg, uint32_t mailbox,
+        can_status_t status);
+typedef void (*can_rx_handler_t)(handler_arg_t arg, uint32_t mailbox,
+        uint16_t id, const uint8_t *data, uint8_t length);
+
+void can_enable(can_t can, uint32_t baudrate);
+void can_disable(can_t can);
+
+void can_set_tx_handler(can_t can, can_tx_handler_t handler, handler_arg_t arg);
+void can_set_rx_handler(can_t can, can_rx_handler_t handler, handler_arg_t arg);
+
+can_status_t can_transmit(can_t can, uint32_t mailbox, uint16_t id,
+        const uint8_t* data, uint8_t length);
+
+#endif /* CAN_H_ */
diff --git a/drivers/gpio.h b/drivers/gpio.h
index 60b55ea..e708192 100644
--- a/drivers/gpio.h
+++ b/drivers/gpio.h
@@ -69,7 +69,23 @@ typedef enum
     GPIO_PIN_12 = 12,
     GPIO_PIN_13 = 13,
     GPIO_PIN_14 = 14,
-    GPIO_PIN_15 = 15
+    GPIO_PIN_15 = 15,
+    GPIO_PIN_16 = 16,
+    GPIO_PIN_17 = 17,
+    GPIO_PIN_18 = 18,
+    GPIO_PIN_19 = 19,
+    GPIO_PIN_20 = 20,
+    GPIO_PIN_21 = 21,
+    GPIO_PIN_22 = 22,
+    GPIO_PIN_23 = 23,
+    GPIO_PIN_24 = 24,
+    GPIO_PIN_25 = 25,
+    GPIO_PIN_26 = 26,
+    GPIO_PIN_27 = 27,
+    GPIO_PIN_28 = 28,
+    GPIO_PIN_29 = 29,
+    GPIO_PIN_30 = 30,
+    GPIO_PIN_31 = 31
 } gpio_pin_t;

 /**
@@ -272,6 +288,9 @@ void gpio_set_i2c_scl(gpio_t gpio, gpio_pin_t pin);
  */
 void gpio_set_timer_output(gpio_t gpio, gpio_pin_t pin, uint32_t alternate);

+void gpio_set_can_rx(gpio_t gpio, gpio_pin_t pin);
+void gpio_set_can_tx(gpio_t gpio, gpio_pin_t pin);
+
 /**
  * @}
  * @}
diff --git a/drivers/stm32/can.c b/drivers/stm32/can.c
new file mode 100644
index 0000000..467913c
--- /dev/null
+++ b/drivers/stm32/can.c
@@ -0,0 +1,307 @@
+/*
+ * can.c
+ *
+ *  Created on: Dec 18, 2011
+ *      Author: clem
+ */
+#include <stdint.h>
+#include "can_.h"
+#include "can_registers.h"
+
+#define LOG_LEVEL 3
+#include "debug.h"
+
+#define ENABLE_BKPT 0
+
+void can_enable(can_t can, uint32_t baudrate) {
+    const _can_t *_can = can;
+
+    // Enable the CAN in the RCC
+    rcc_apb_enable(RCC_APB_BUS_CAN1, RCC_APB_BIT_CAN1);
+    rcc_apb_enable(_can->apb_bus, _can->apb_bit);
+
+    // Reset the CAN in APBr
+    rcc_apb_reset(RCC_APB_BUS_CAN1, RCC_APB_BIT_CAN1);
+    rcc_apb_reset(_can->apb_bus, _can->apb_bit);
+
+    // Reset the CAN
+    *can_get_MCR(_can) |= CAN_MCR__RESET;
+    *can_get_MCR(_can) = 0;
+
+    // Request initialization mode
+    *can_get_MCR(_can) = CAN_MCR__INRQ;
+
+    // Wait until ACKed
+    while ((*can_get_MSR(_can) & CAN_MSR__INAK) == 0) {
+    }
+
+    // Set Bitrate in BTR
+    uint32_t pclock =
+            (_can->apb_bus == 1) ?
+                    rcc_sysclk_get_clock_frequency(RCC_SYSCLK_CLOCK_PCLK1) :
+                    rcc_sysclk_get_clock_frequency(RCC_SYSCLK_CLOCK_PCLK2);
+
+    *can_get_BTR(_can) = (1 << 24) | (3 << 20) | (5 << 16)
+            | (pclock / baudrate - 1);
+
+    // Set debug options
+    //    *can_get_BTR(_can) |= CAN_BTR__LBKM | CAN_BTR__SILM;
+
+    // Set Options in MCR
+    *can_get_MCR(_can) = CAN_MCR__ABOM | CAN_MCR__NART | CAN_MCR__INRQ;
+
+    // Set the interrupts
+    *can_get_IER(_can) = CAN_IER__ERRIE | CAN_IER__EPVIE | CAN_IER__TMEIE
+            | CAN_IER__FOVIE0 | CAN_IER__FFIE0 | CAN_IER__FMPIE0
+            | CAN_IER__FOVIE1 | CAN_IER__FFIE1 | CAN_IER__FMPIE1;
+
+    // Leave initialization
+    *can_get_MCR(_can) &= ~CAN_MCR__INRQ;
+
+    // Wait until ACKed
+    while (*can_get_MSR(_can) & CAN_MSR__INAK) {
+    }
+
+    // Set a filter for can1 and can2
+    *can_get_FMR() = CAN_FMR__FINIT;
+    *can_get_FMR() = (14 << 8) | CAN_FMR__FINIT;
+
+    *can_get_FM1R() = 0;
+    *can_get_FS1R() = 0;
+    *can_get_FFA1R() = 0;
+    *can_get_FA1R() = (1 << 14) | (1 << 0);
+    *can_get_FxR1(0) = 0;
+    *can_get_FxR2(0) = 0;
+
+    // Clear the FINIT bit
+    *can_get_FMR() = 0;
+
+    // Enable interrupts
+    nvic_enable_interrupt_line(_can->irq_line_tx);
+    nvic_enable_interrupt_line(_can->irq_line_rx0);
+    nvic_enable_interrupt_line(_can->irq_line_rx1);
+    nvic_enable_interrupt_line(_can->irq_line_sce);
+
+    log_debug("CAN debug:");
+    log_debug("\tMCR: %x", *can_get_MCR(_can));
+    log_debug("\tBTR: %x", *can_get_BTR(_can));
+    log_debug("\tIER: %x", *can_get_IER(_can));
+    log_debug("\tESR: %x", *can_get_ESR(_can));
+    log_debug("\tFMR: %x", *can_get_FMR());
+    log_debug("\tFM1R: %x", *can_get_FM1R());
+    log_debug("\tFS1R: %x", *can_get_FS1R());
+    log_debug("\tFFA1R: %x", *can_get_FFA1R());
+    log_debug("\tFA1R: %x", *can_get_FA1R());
+    log_debug("\tFxR1_0: %x", *can_get_FxR1(0));
+    log_debug("\tFxR2_0: %x", *can_get_FxR2(0));
+}
+void can_disable(can_t can) {
+    const _can_t *_can = can;
+
+    // Disable the CAN in the RCC
+    rcc_apb_disable(_can->apb_bus, _can->apb_bit);
+}
+
+void can_set_tx_handler(can_t can, can_tx_handler_t handler, handler_arg_t arg) {
+    const _can_t *_can = can;
+
+    // Store handler and arg
+    _can->data->tx_handler = handler;
+    _can->data->tx_arg = arg;
+}
+void can_set_rx_handler(can_t can, can_rx_handler_t handler, handler_arg_t arg) {
+    const _can_t *_can = can;
+
+    // Store handler and arg
+    _can->data->rx_handler = handler;
+    _can->data->rx_arg = arg;
+}
+
+can_status_t can_transmit(can_t can, uint32_t mailbox, uint16_t id,
+        const uint8_t* data, uint8_t length) {
+    const _can_t *_can = can;
+
+    // Check length
+    if (length > 8) {
+        log_error("Length too big");
+        return CAN_ERR_TOO_BIG;
+    }
+
+    // Check mailbox
+    if (mailbox > 2) {
+        log_error("Invalid Mailbox");
+        return CAN_ERR_TX_INVALID_MAILBOX;
+    }
+
+    // Check if the first fifo is empty
+    if (*can_get_TIxR(_can, mailbox) & CAN_TIxR__TXRQ) {
+        log_error("TX mailbox not empty!");
+        return CAN_ERR_TX_MAILBOX_FULL;
+    }
+
+    // Set the identifier
+    *can_get_TIxR(_can, mailbox) = (id << 21);
+
+    // Set the data length
+    *can_get_TDTxR(_can, mailbox) = length;
+
+    // Copy the data
+    uint32_t i;
+
+    *can_get_TDLxR(_can, mailbox) = 0;
+    *can_get_TDHxR(_can, mailbox) = 0;
+
+    for (i = 0; i < length; i++) {
+        if (i < 4) {
+            *can_get_TDLxR(_can, mailbox) |= ((uint32_t) data[i]) << (8 * i);
+        } else {
+            *can_get_TDHxR(_can, mailbox) |= ((uint32_t) data[i])
+                    << (8 * (i - 4));
+        }
+    }
+
+    // Request transmission
+    *can_get_TIxR(_can, mailbox) |= CAN_TIxR__TXRQ;
+
+    // Wait until sent!
+    while (*can_get_TIxR(_can, mailbox) & CAN_TIxR__TXRQ) {
+    }
+
+    return CAN_OK;
+
+}
+
+void can_handle_tx_interrupt(const const _can_t *_can) {
+    // Get the first mailbox to have triggered
+    uint32_t mailbox;
+    uint32_t tsr = *can_get_TSR(_can);
+
+    if (tsr & CAN_TSR__RQCP0) {
+        mailbox = 0;
+    } else if (tsr & CAN_TSR__RQCP1) {
+        mailbox = 1;
+    } else if (tsr & CAN_TSR__RQCP2) {
+        mailbox = 2;
+    } else {
+        // Error
+        return;
+    }
+
+    log_debug("TSR: %x", tsr);
+
+    // Set the bit to clear it
+    *can_get_TSR(_can) = CAN_TSR__RQCP0 << (8 * mailbox);
+
+    // Get status
+    can_status_t status;
+    if (tsr & (CAN_TSR__TXOK0 << (8 * mailbox))) {
+        status = CAN_OK;
+        log_info("TX mailbox %u: OK", mailbox);
+    } else {
+        status = CAN_ERR_TX_FAILED;
+        log_error("TX mailbox %u: Failed", mailbox);
+#if ENABLE_BKPT
+        asm ("bkpt 0");
+#endif
+    }
+
+    // Call handler if any
+    if (_can->data->tx_handler) {
+        _can->data->tx_handler(_can->data->tx_arg, mailbox, status);
+    }
+}
+
+static void can_handle_rx_interrupt(const const _can_t *_can, uint32_t fifo) {
+    volatile uint32_t *rfxr = can_get_RFxR(_can, fifo);
+    uint32_t rfxr_value = *rfxr;
+
+    if (rfxr_value & CAN_RFxR__FMP_MASK) {
+        log_info("RX%u interrupt FMP: %x", fifo,
+                rfxr_value & CAN_RFxR__FMP_MASK);
+
+        // Get the parameters of the received message
+        uint16_t id = (*can_get_RIxR(_can, fifo) & CAN_RIxR__STDID_MASK) >> 21;
+        uint8_t length = *can_get_RDTxR(_can, fifo) & 0xF;
+        uint8_t *data = (uint8_t*) (uint32_t) can_get_RDLxR(_can, fifo);
+
+        // Call handler if any
+        if (_can->data->rx_handler) {
+            _can->data->rx_handler(_can->data->rx_arg, 0, id, data, length);
+        }
+
+        // Clear the message from the the RX FIFO
+        *rfxr = CAN_RFxR__RFOM;
+    }
+    if (*rfxr & CAN_RFxR__FULL) {
+        log_error("RX%u interrupt FULL0", fifo);
+
+#if ENABLE_BKPT
+        asm ("bkpt 0");
+#endif
+
+        // Set the bit to clear
+        *rfxr = CAN_RFxR__FULL;
+    }
+    if (*rfxr & CAN_RFxR__FOVR) {
+        log_info("RX%u interrupt Overrun0", fifo);
+#if ENABLE_BKPT
+        asm ("bkpt 0");
+#endif
+
+        // Set the bit to clear
+        *rfxr = CAN_RFxR__FOVR;
+    }
+
+}
+void can_handle_rx0_interrupt(const const _can_t *_can) {
+    can_handle_rx_interrupt(_can, 0);
+}
+void can_handle_rx1_interrupt(const const _can_t *_can) {
+    can_handle_rx_interrupt(_can, 1);
+}
+void can_handle_sce_interrupt(const const _can_t *_can) {
+    uint32_t esr = *can_get_ESR(_can);
+    log_info("SCE interrupt, ESR: %x, TSR %x", esr, *can_get_TSR(_can));
+
+    if (esr & CAN_ESR__EPVF) {
+        // Check if TX error
+        if ((esr & CAN_ESR__TEC_MASK) >> 16 >= 128) {
+            // Find the current mailbox being sent
+            if (*can_get_TSR(_can) & (CAN_TSR__TERR0 | CAN_TSR__ALST0)) {
+                log_error("TX 0 error, aborting");
+
+#if ENABLE_BKPT
+                asm ("bkpt 0");
+#endif
+
+                // Abort and clear all flags
+                *can_get_TSR(_can) = CAN_TSR__ABRQ0;
+            } else
+            // Find the current mailbox being sent
+            if (*can_get_TSR(_can) & (CAN_TSR__TERR1 | CAN_TSR__ALST1)) {
+                log_error("TX 1 error, aborting");
+
+#if ENABLE_BKPT
+                asm ("bkpt 0");
+#endif
+
+                // Abort and clear all flags
+                *can_get_TSR(_can) = CAN_TSR__ABRQ1;
+            } else
+            // Find the current mailbox being sent
+            if (*can_get_TSR(_can) & (CAN_TSR__TERR2 | CAN_TSR__ALST2)) {
+                log_error("TX 2 error, aborting");
+
+#if ENABLE_BKPT
+                asm ("bkpt 0");
+#endif
+
+                // Abort
+                *can_get_TSR(_can) = CAN_TSR__ABRQ2;
+            }
+        }
+    }
+
+    // Clear the Error Bit
+    *can_get_MSR(_can) = CAN_MSR__ERRI;
+}
diff --git a/drivers/stm32/can_.h b/drivers/stm32/can_.h
new file mode 100644
index 0000000..cec320e
--- /dev/null
+++ b/drivers/stm32/can_.h
@@ -0,0 +1,72 @@
+/*
+ * can_.h
+ *
+ *  Created on: Dec 18, 2011
+ *      Author: clem
+ */
+
+#ifndef CAN__H_
+#define CAN__H_
+
+#include <stdint.h>
+
+#include "can.h"
+#include "rcc.h"
+#include "nvic.h"
+#include "gpio.h"
+#include "handler.h"
+
+typedef struct
+{
+    can_tx_handler_t tx_handler;
+    can_rx_handler_t rx_handler;
+    handler_arg_t tx_arg, rx_arg;
+} _can_data_t;
+
+typedef struct
+{
+    uint32_t base_address;
+
+    rcc_apb_bus_t apb_bus;
+    rcc_apb_bit_t apb_bit;
+
+    nvic_irq_line_t irq_line_tx, irq_line_rx0, irq_line_rx1, irq_line_sce;
+
+    _can_data_t *data;
+} _can_t;
+
+/**
+ * Initialize the CAN object, with all the required parameters.
+ */
+static inline void can_init(_can_t *_can, uint32_t base_address,
+        rcc_apb_bus_t apb_bus, rcc_apb_bit_t apb_bit,
+        nvic_irq_line_t irq_line_tx, nvic_irq_line_t irq_line_rx0,
+        nvic_irq_line_t irq_line_rx1, nvic_irq_line_t irq_line_sce)
+{
+    _can->base_address = base_address;
+    _can->apb_bus = apb_bus;
+    _can->apb_bit = apb_bit;
+
+    _can->data->tx_handler = NULL;
+    _can->data->rx_handler = NULL;
+}
+
+#define CAN_INIT(name, addr, bus, bit, line_tx, line_rx0, line_rx1, line_sce) \
+    static _can_data_t name##_data; \
+    const _can_t name = { \
+    .base_address = addr, \
+    .apb_bus = bus, \
+    .apb_bit = bit, \
+    .irq_line_tx = line_tx, \
+    .irq_line_rx0 = line_rx0, \
+    .irq_line_rx1 = line_rx1, \
+    .irq_line_sce = line_sce, \
+    .data = &name##_data \
+}
+
+void can_handle_tx_interrupt(const _can_t *_can);
+void can_handle_rx0_interrupt(const _can_t *_can);
+void can_handle_rx1_interrupt(const _can_t *_can);
+void can_handle_sce_interrupt(const _can_t *_can);
+
+#endif /* CAN__H_ */
diff --git a/drivers/stm32/can_registers.h b/drivers/stm32/can_registers.h
new file mode 100644
index 0000000..baae8a1
--- /dev/null
+++ b/drivers/stm32/can_registers.h
@@ -0,0 +1,283 @@
+/*
+ * can_registers.h
+ *
+ *  Created on: Dec 18, 2011
+ *      Author: clem
+ */
+
+#ifndef CAN_REGISTERS_H_
+#define CAN_REGISTERS_H_
+
+#include <stdint.h>
+#include "memmap.h"
+
+#include "can_.h"
+
+static inline volatile uint32_t* can_get_MCR(const _can_t* _can)
+{
+    return mem_get_reg32(_can->base_address + CAN_MCR_OFFSET);
+}
+
+enum
+{
+    CAN_MCR__DBF = 0x10000,
+    CAN_MCR__RESET = 0x8000,
+    CAN_MCR__TTCM = 0x80,
+    CAN_MCR__ABOM = 0x40,
+    CAN_MCR__AWUM = 0x20,
+    CAN_MCR__NART = 0x10,
+    CAN_MCR__RFLM = 0x08,
+    CAN_MCR__TXFP = 0x04,
+    CAN_MCR__SLEEP = 0x02,
+    CAN_MCR__INRQ = 0x01,
+};
+
+static inline volatile uint32_t* can_get_MSR(const _can_t* _can)
+{
+    return mem_get_reg32(_can->base_address + CAN_MSR_OFFSET);
+}
+
+enum
+{
+    CAN_MSR__RX = 0x0800,
+    CAN_MSR__SAMP = 0x0400,
+    CAN_MSR__RXM = 0x0200,
+    CAN_MSR__TXM = 0x0100,
+    CAN_MSR__SLAKI = 0x0010,
+    CAN_MSR__WKUI = 0x0008,
+    CAN_MSR__ERRI = 0x0004,
+    CAN_MSR__SLAK = 0x0002,
+    CAN_MSR__INAK = 0x0001,
+};
+
+static inline volatile uint32_t* can_get_TSR(const _can_t* _can)
+{
+    return mem_get_reg32(_can->base_address + CAN_TSR_OFFSET);
+}
+
+enum
+{
+    CAN_TSR__LOW2 = 0x80000000,
+    CAN_TSR__LOW1 = 0x40000000,
+    CAN_TSR__LOW0 = 0x20000000,
+    CAN_TSR__TME2 = 0x10000000,
+    CAN_TSR__TME1 = 0x08000000,
+    CAN_TSR__TME0 = 0x04000000,
+    CAN_TSR__CODE_MASK = 0x03000000,
+
+    CAN_TSR__ABRQ2 = 0x00800000,
+    CAN_TSR__TERR2 = 0x00080000,
+    CAN_TSR__ALST2 = 0x00040000,
+    CAN_TSR__TXOK2 = 0x00020000,
+    CAN_TSR__RQCP2 = 0x00010000,
+
+    CAN_TSR__ABRQ1 = 0x00008000,
+    CAN_TSR__TERR1 = 0x00000800,
+    CAN_TSR__ALST1 = 0x00000400,
+    CAN_TSR__TXOK1 = 0x00000200,
+    CAN_TSR__RQCP1 = 0x00000100,
+
+    CAN_TSR__ABRQ0 = 0x00000080,
+    CAN_TSR__TERR0 = 0x00000008,
+    CAN_TSR__ALST0 = 0x00000004,
+    CAN_TSR__TXOK0 = 0x00000002,
+    CAN_TSR__RQCP0 = 0x00000001,
+};
+
+static inline volatile uint32_t* can_get_RFxR(const _can_t* _can, uint32_t fifo)
+{
+    if (fifo == 0)
+    {
+        return mem_get_reg32(_can->base_address + CAN_RF0R_OFFSET);
+    }
+    else
+    {
+        return mem_get_reg32(_can->base_address + CAN_RF1R_OFFSET);
+    }
+}
+enum
+{
+    CAN_RFxR__RFOM = 0x20,
+    CAN_RFxR__FOVR = 0x10,
+    CAN_RFxR__FULL = 0x08,
+    CAN_RFxR__FMP_MASK = 0x03,
+};
+
+static inline volatile uint32_t* can_get_IER(const _can_t* _can)
+{
+    return mem_get_reg32(_can->base_address + CAN_IER_OFFSET);
+}
+
+enum
+{
+    CAN_IER__SLKIE = 0x020000,
+    CAN_IER__WKUIE = 0x010000,
+    CAN_IER__ERRIE = 0x8000,
+    CAN_IER__LECIE = 0x0800,
+    CAN_IER__BOFIE = 0x0400,
+    CAN_IER__EPVIE = 0x0200,
+    CAN_IER__EWGIE = 0x0100,
+    CAN_IER__FOVIE1 = 0x0040,
+    CAN_IER__FFIE1 = 0x0020,
+    CAN_IER__FMPIE1 = 0x0010,
+    CAN_IER__FOVIE0 = 0x0008,
+    CAN_IER__FFIE0 = 0x0004,
+    CAN_IER__FMPIE0 = 0x0002,
+    CAN_IER__TMEIE = 0x0001,
+};
+
+static inline volatile uint32_t* can_get_ESR(const _can_t* _can)
+{
+    return mem_get_reg32(_can->base_address + CAN_ESR_OFFSET);
+}
+
+enum
+{
+    CAN_ESR__REC_MASK = 0xFF000000,
+    CAN_ESR__TEC_MASK = 0x00FF0000,
+    CAN_ESR__LEC_MASK = 0x00000070,
+    CAN_ESR__BOFF = 0x00000004,
+    CAN_ESR__EPVF = 0x00000002,
+    CAN_ESR__EWGF = 0x00000001,
+};
+
+static inline volatile uint32_t* can_get_BTR(const _can_t* _can)
+{
+    return mem_get_reg32(_can->base_address + CAN_BTR_OFFSET);
+}
+
+enum
+{
+    CAN_BTR__SILM = 0x80000000,
+    CAN_BTR__LBKM = 0x40000000,
+    CAN_BTR__SJW_MASK = 0x03000000,
+    CAN_BTR__TS2_MASK = 0x00700000,
+    CAN_BTR__TS1_MASK = 0x000F0000,
+    CAN_BTR__BRP_MASK = 0x000003FF,
+};
+
+/** mailbox is 0-2 */
+static inline volatile uint32_t* can_get_TIxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_TI0R_OFFSET + mailbox * (CAN_TIxR_OFFSET));
+}
+
+enum
+{
+    CAN_TIxR__STDID_MASK = 0xFFE00000,
+    CAN_TIxR__EXID_MASK = 0xFFFFFFF8,
+    CAN_TIxR__IDE = 0x00000004,
+    CAN_TIxR__RTR = 0x00000002,
+    CAN_TIxR__TXRQ = 0x00000001,
+};
+
+/** mailbox is 0-2 */
+static inline volatile uint32_t* can_get_TDTxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_TDT0R_OFFSET + mailbox * (CAN_TIxR_OFFSET));
+}
+
+enum
+{
+    CAN_TDTxR__TIME_MASK = 0xFFFF0000,
+    CAN_TDTxR__TGT = 0x00000100,
+    CAN_TDTxR__DLC_MASK = 0x0000000F,
+};
+
+/** mailbox is 0-2 */
+static inline volatile uint32_t* can_get_TDLxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_TDL0R_OFFSET + mailbox * (CAN_TIxR_OFFSET));
+}
+/** mailbox is 0-2 */
+static inline volatile uint32_t* can_get_TDHxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_TDH0R_OFFSET + mailbox * (CAN_TIxR_OFFSET));
+}
+
+/** mailbox is 0-1 */
+static inline volatile uint32_t* can_get_RIxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_RI0R_OFFSET + mailbox * (CAN_RIxR_OFFSET));
+}
+
+enum
+{
+    CAN_RIxR__STDID_MASK = 0xFFE00000,
+    CAN_RIxR__EXID_MASK = 0xFFFFFFF8,
+    CAN_RIxR__IDE = 0x00000004,
+    CAN_RIxR__RTR = 0x00000002,
+};
+
+/** mailbox is 0-1 */
+static inline volatile uint32_t* can_get_RDTxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_RDT0R_OFFSET + mailbox * (CAN_RIxR_OFFSET));
+}
+
+enum
+{
+    CAN_RDTxR__TIME_MASK = 0xFFFF0000,
+    CAN_RDTxR__FMI_MASK = 0x0000FF00,
+    CAN_RDTxR__DLC_MASK = 0x0000000F,
+};
+
+/** mailbox is 0-1 */
+static inline volatile uint32_t* can_get_RDLxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_RDL0R_OFFSET + mailbox * (CAN_RIxR_OFFSET));
+}
+/** mailbox is 0-1 */
+static inline volatile uint32_t* can_get_RDHxR(const _can_t* _can, uint32_t mailbox)
+{
+    return mem_get_reg32(
+            _can->base_address + CAN_RDH0R_OFFSET + mailbox * (CAN_RIxR_OFFSET));
+}
+
+static inline volatile uint32_t* can_get_FMR()
+{
+    return mem_get_reg32(CAN1_BASE_ADDRESS + CAN_FMR_OFFSET);
+}
+
+enum
+{
+    CAN_FMR__FINIT = 0x1,
+};
+
+static inline volatile uint32_t* can_get_FM1R()
+{
+    return mem_get_reg32(CAN1_BASE_ADDRESS + CAN_FM1R_OFFSET);
+}
+static inline volatile uint32_t* can_get_FS1R()
+{
+    return mem_get_reg32(CAN1_BASE_ADDRESS + CAN_FS1R_OFFSET);
+}
+static inline volatile uint32_t* can_get_FFA1R()
+{
+    return mem_get_reg32(CAN1_BASE_ADDRESS + CAN_FFA1R_OFFSET);
+}
+static inline volatile uint32_t* can_get_FA1R()
+{
+    return mem_get_reg32(CAN1_BASE_ADDRESS + CAN_FA1R_OFFSET);
+}
+/** bank is 0-27 */
+static inline volatile uint32_t* can_get_FxR1(uint32_t bank)
+{
+    return mem_get_reg32(
+            CAN1_BASE_ADDRESS + CAN_F0R1_OFFSET + bank * CAN_FORx_OFFSET);
+}
+/** bank is 0-27 */
+static inline volatile uint32_t* can_get_FxR2(uint32_t bank)
+{
+    return mem_get_reg32(
+            CAN1_BASE_ADDRESS + CAN_F0R2_OFFSET + bank * CAN_FORx_OFFSET);
+}
+
+#endif /* CAN_REGISTERS_H_ */
diff --git a/drivers/stm32f4xx/gpio.c b/drivers/stm32f4xx/gpio.c
index 0e92f6e..a5801d1 100644
--- a/drivers/stm32f4xx/gpio.c
+++ b/drivers/stm32f4xx/gpio.c
@@ -232,3 +232,14 @@ void gpio_set_timer_output(gpio_t gpio, gpio_pin_t pin, uint32_t alternate)
     // Set alternate function
     gpio_set_alternate_function(gpio, pin, alternate);
 }
+
+void gpio_set_can_rx(gpio_t gpio, gpio_pin_t pin)
+{
+    // Just set alternate
+    gpio_set_alternate_function(gpio, pin, GPIO_AF_9);
+}
+void gpio_set_can_tx(gpio_t gpio, gpio_pin_t pin)
+{
+    // Just set alternate
+    gpio_set_alternate_function(gpio, pin, GPIO_AF_9);
+}
diff --git a/drivers/stm32f4xx/gpio_.h b/drivers/stm32f4xx/gpio_.h
index b250214..896c74d 100644
--- a/drivers/stm32f4xx/gpio_.h
+++ b/drivers/stm32f4xx/gpio_.h
@@ -48,14 +48,20 @@ typedef enum
 {
     GPIO_AF_0 = 0, // SYS
     GPIO_AF_1 = 1, // TIM 1/2
+    GPIO_AF_TIM1_TIM2 = 1,
     GPIO_AF_2 = 2, // TIM 3/4/5
+    GPIO_AF_TIM3_TIM4_TIM5 = 2,
     GPIO_AF_3 = 3, // TIM 8/9/10/11
+    GPIO_AF_TIM8_TIM9_TIM10_TIM11 = 3,
     GPIO_AF_4 = 4, // I2C 1/2/3
+    GPIO_AF_I2C1_I2C2_I2C3 = 4,
     GPIO_AF_5 = 5, // SPI 1/2 I2S 1/2
+    GPIO_AF_SPI1_SPI2_I2S1_I2S2 = 5,
     GPIO_AF_6 = 6, // SPI 3 I2S 3
     GPIO_AF_7 = 7, // USART 1/2/3
     GPIO_AF_8 = 8, // USART 4/5/6
     GPIO_AF_9 = 9, // CAN 1/2 TIM 12/13/14
+    GPIO_AF_CAN1_CAN2_TIM12_TIM13_TIM14 = 9,
     GPIO_AF_10 = 10, // OTG
     GPIO_AF_11 = 11, // ETH
     GPIO_AF_12 = 12, // FSMC SDIO
diff --git a/drivers/stm32f4xx/memmap.h b/drivers/stm32f4xx/memmap.h
index 0a40451..32972b9 100644
--- a/drivers/stm32f4xx/memmap.h
+++ b/drivers/stm32f4xx/memmap.h
@@ -30,369 +30,409 @@
 #include <stdint.h>
 #include "cm3_memmap.h"

-#define	FSMC_BASE_ADDRESS		0xA0000000
-#define	RNG_BASE_ADDRESS		0x50060800
-#define	HASH_BASE_ADDRESS		0x50060400
-#define	CRYP_BASE_ADDRESS		0x50060000
-#define	DCMI_BASE_ADDRESS		0x50050000
-#define	USB_OTG_FS_BASE_ADDRESS	0x50000000
-#define	USB_OTG_HS_BASE_ADDRESS	0x40040000
-#define	ETHMAC_BASE_ADDRESS		0x40028000
-#define	DMA2_BASE_ADDRESS		0x40026400
-#define	DMA1_BASE_ADDRESS		0x40026000
-#define	BKPSRAM_BASE_ADDRESS	0x40024000
-#define	FLASH_BASE_ADDRESS		0x40023C00
-#define	RCC_BASE_ADDRESS		0x40023800
-#define	CRC_BASE_ADDRESS		0x40023000
-#define	GPIOI_BASE_ADDRESS 		0x40022000
-#define	GPIOH_BASE_ADDRESS 		0x40021C00
-#define	GPIOG_BASE_ADDRESS		0x40021800
-#define	GPIOF_BASE_ADDRESS		0x40021400
-#define	GPIOE_BASE_ADDRESS 		0x40021000
-#define	GPIOD_BASE_ADDRESS		0x40020C00
-#define	GPIOC_BASE_ADDRESS		0x40020800
-#define	GPIOB_BASE_ADDRESS		0x40020400
-#define	GPIOA_BASE_ADDRESS		0x40020000
-#define	TIM11_BASE_ADDRESS		0x40014800
-#define	TIM10_BASE_ADDRESS		0x40014400
-#define	TIM9_BASE_ADDRESS		0x40014000
-#define	EXTI_BASE_ADDRESS		0x40013C00
-#define	SYSCFG_BASE_ADDRESS		0x40013800
-#define	SPI1_BASE_ADDRESS		0x40013000
-#define	SDIO_BASE_ADDRESS		0x40012C00
-#define	ADC_BASE_ADDRESS		0x40012000
-#define	USART6_BASE_ADDRESS		0x40011400
-#define	USART1_BASE_ADDRESS		0x40011000
-#define	TIM8_BASE_ADDRESS		0x40010400
-#define	TIM1_BASE_ADDRESS		0x40010000
-
-#define	DAC_BASE_ADDRESS		0x40007400
-#define	PWR_BASE_ADDRESS		0x40007000
-#define	CAN2_BASE_ADDRESS		0x40006800
-#define	CAN1_BASE_ADDRESS		0x40006400
-#define	I2C3_BASE_ADDRESS		0x40005C00
-#define	I2C2_BASE_ADDRESS		0x40005800
-#define	I2C1_BASE_ADDRESS		0x40005400
-#define	UART5_BASE_ADDRESS		0x40005000
-#define	UART4_BASE_ADDRESS		0x40004C00
-#define	USART3_BASE_ADDRESS		0x40004800
-#define	USART2_BASE_ADDRESS		0x40004400
-#define	I2S3EXT_BASE_ADDRESS	0x40004000
-#define	SPI3_BASE_ADDRESS		0x40003C00
-#define	SPI2_BASE_ADDRESS		0x40003800
-#define	I2S2EXT_BASE_ADDRESS	0x40003400
-#define	IWDG_BASE_ADDRESS		0x40003000
-#define	WWDG_BASE_ADDRESS		0x40002C00
-#define	RTC_BASE_ADDRESS		0x40002800
-#define	TIM14_BASE_ADDRESS		0x40002000
-#define	TIM13_BASE_ADDRESS		0x40001C00
-#define	TIM12_BASE_ADDRESS		0x40001800
-#define	TIM7_BASE_ADDRESS		0x40001400
-#define	TIM6_BASE_ADDRESS		0x40001000
-#define	TIM5_BASE_ADDRESS		0x40000C00
-#define	TIM4_BASE_ADDRESS		0x40000800
-#define	TIM3_BASE_ADDRESS		0x40000400
-#define	TIM2_BASE_ADDRESS		0x40000000
-
+enum
+{
+    FSMC_BASE_ADDRESS = 0xA0000000,
+    RNG_BASE_ADDRESS = 0x50060800,
+    HASH_BASE_ADDRESS = 0x50060400,
+    CRYP_BASE_ADDRESS = 0x50060000,
+    DCMI_BASE_ADDRESS = 0x50050000,
+    USB_OTG_FS_BASE_ADDRESS = 0x50000000,
+    USB_OTG_HS_BASE_ADDRESS = 0x40040000,
+    ETHMAC_BASE_ADDRESS = 0x40028000,
+    DMA2_BASE_ADDRESS = 0x40026400,
+    DMA1_BASE_ADDRESS = 0x40026000,
+    BKPSRAM_BASE_ADDRESS = 0x40024000,
+    FLASH_BASE_ADDRESS = 0x40023C00,
+    RCC_BASE_ADDRESS = 0x40023800,
+    CRC_BASE_ADDRESS = 0x40023000,
+    GPIOI_BASE_ADDRESS = 0x40022000,
+    GPIOH_BASE_ADDRESS = 0x40021C00,
+    GPIOG_BASE_ADDRESS = 0x40021800,
+    GPIOF_BASE_ADDRESS = 0x40021400,
+    GPIOE_BASE_ADDRESS = 0x40021000,
+    GPIOD_BASE_ADDRESS = 0x40020C00,
+    GPIOC_BASE_ADDRESS = 0x40020800,
+    GPIOB_BASE_ADDRESS = 0x40020400,
+    GPIOA_BASE_ADDRESS = 0x40020000,
+    TIM11_BASE_ADDRESS = 0x40014800,
+    TIM10_BASE_ADDRESS = 0x40014400,
+    TIM9_BASE_ADDRESS = 0x40014000,
+    EXTI_BASE_ADDRESS = 0x40013C00,
+    SYSCFG_BASE_ADDRESS = 0x40013800,
+    SPI1_BASE_ADDRESS = 0x40013000,
+    SDIO_BASE_ADDRESS = 0x40012C00,
+    ADC_BASE_ADDRESS = 0x40012000,
+    USART6_BASE_ADDRESS = 0x40011400,
+    USART1_BASE_ADDRESS = 0x40011000,
+    TIM8_BASE_ADDRESS = 0x40010400,
+    TIM1_BASE_ADDRESS = 0x40010000,
+
+    DAC_BASE_ADDRESS = 0x40007400,
+    PWR_BASE_ADDRESS = 0x40007000,
+    CAN2_BASE_ADDRESS = 0x40006800,
+    CAN1_BASE_ADDRESS = 0x40006400,
+    I2C3_BASE_ADDRESS = 0x40005C00,
+    I2C2_BASE_ADDRESS = 0x40005800,
+    I2C1_BASE_ADDRESS = 0x40005400,
+    UART5_BASE_ADDRESS = 0x40005000,
+    UART4_BASE_ADDRESS = 0x40004C00,
+    USART3_BASE_ADDRESS = 0x40004800,
+    USART2_BASE_ADDRESS = 0x40004400,
+    I2S3EXT_BASE_ADDRESS = 0x40004000,
+    SPI3_BASE_ADDRESS = 0x40003C00,
+    SPI2_BASE_ADDRESS = 0x40003800,
+    I2S2EXT_BASE_ADDRESS = 0x40003400,
+    IWDG_BASE_ADDRESS = 0x40003000,
+    WWDG_BASE_ADDRESS = 0x40002C00,
+    RTC_BASE_ADDRESS = 0x40002800,
+    TIM14_BASE_ADDRESS = 0x40002000,
+    TIM13_BASE_ADDRESS = 0x40001C00,
+    TIM12_BASE_ADDRESS = 0x40001800,
+    TIM7_BASE_ADDRESS = 0x40001400,
+    TIM6_BASE_ADDRESS = 0x40001000,
+    TIM5_BASE_ADDRESS = 0x40000C00,
+    TIM4_BASE_ADDRESS = 0x40000800,
+    TIM3_BASE_ADDRESS = 0x40000400,
+    TIM2_BASE_ADDRESS = 0x40000000,
+};

 /* RCC section */
-#define	RCC_CR_OFFSET			0x00
-#define RCC_PLLCFGR_OFFSET		0x04
-#define	RCC_CFGR_OFFSET			0x08
-#define	RCC_CIR_OFFSET			0x0C
-#define	RCC_AHB1RSTR_OFFSET		0x10
-#define	RCC_AHB2RSTR_OFFSET		0x14
-#define	RCC_AHB3RSTR_OFFSET		0x18
-#define	RCC_APB1RSTR_OFFSET		0x20
-#define	RCC_APB2RSTR_OFFSET		0x24
-#define	RCC_AHB1ENR_OFFSET		0x30
-#define	RCC_AHB2ENR_OFFSET		0x34
-#define	RCC_AHB3ENR_OFFSET		0x38
-#define	RCC_APB1ENR_OFFSET		0x40
-#define	RCC_APB2ENR_OFFSET		0x44
-#define	RCC_AHB1LPENR_OFFSET	0x50
-#define	RCC_AHB2LPENR_OFFSET	0x54
-#define	RCC_AHB3LPENR_OFFSET	0x58
-#define	RCC_APB1LPENR_OFFSET	0x60
-#define	RCC_APB2LPENR_OFFSET	0x64
-#define	RCC_BDCR_OFFSET			0x70
-#define	RCC_CSR_OFFSET			0x74
-#define	RCC_SSCGR_OFFSET		0x80
-#define	RCC_PLLI2SCFGR_OFFSET	0x84
-
+enum
+{
+    RCC_CR_OFFSET = 0x00,
+    RCC_PLLCFGR_OFFSET = 0x04,
+    RCC_CFGR_OFFSET = 0x08,
+    RCC_CIR_OFFSET = 0x0C,
+    RCC_AHB1RSTR_OFFSET = 0x10,
+    RCC_AHB2RSTR_OFFSET = 0x14,
+    RCC_AHB3RSTR_OFFSET = 0x18,
+    RCC_APB1RSTR_OFFSET = 0x20,
+    RCC_APB2RSTR_OFFSET = 0x24,
+    RCC_AHB1ENR_OFFSET = 0x30,
+    RCC_AHB2ENR_OFFSET = 0x34,
+    RCC_AHB3ENR_OFFSET = 0x38,
+    RCC_APB1ENR_OFFSET = 0x40,
+    RCC_APB2ENR_OFFSET = 0x44,
+    RCC_AHB1LPENR_OFFSET = 0x50,
+    RCC_AHB2LPENR_OFFSET = 0x54,
+    RCC_AHB3LPENR_OFFSET = 0x58,
+    RCC_APB1LPENR_OFFSET = 0x60,
+    RCC_APB2LPENR_OFFSET = 0x64,
+    RCC_BDCR_OFFSET = 0x70,
+    RCC_CSR_OFFSET = 0x74,
+    RCC_SSCGR_OFFSET = 0x80,
+    RCC_PLLI2SCFGR_OFFSET = 0x84
+};

 /* FLASH section */
-#define	FLASH_ACR_OFFSET		0x00
-#define	FLASH_KEYR_OFFSET		0x04
-#define	FLASH_OPTKEYR_OFFSET	0x08
-#define	FLASH_SR_OFFSET			0x0C
-#define	FLASH_CR_OFFSET			0x10
-#define	FLASH_OPTCR_OFFSET		0x14
-
+enum
+{
+    FLASH_ACR_OFFSET = 0x00,
+    FLASH_KEYR_OFFSET = 0x04,
+    FLASH_OPTKEYR_OFFSET = 0x08,
+    FLASH_SR_OFFSET = 0x0C,
+    FLASH_CR_OFFSET = 0x10,
+    FLASH_OPTCR_OFFSET = 0x14,
+};

 /* GPIO section */
-#define GPIOx_MODER_OFFSET		0x00
-#define	GPIOx_OTYPER_OFFSET		0x04
-#define	GPIOx_OSPEEDR_OFFSET	0x08
-#define	GPIOx_PUPDR_OFFSET		0x0C
-#define	GPIOx_IDR_OFFSET		0x10
-#define	GPIOx_ODR_OFFSET		0x14
-#define	GPIOx_BSRR_OFFSET		0x18
-#define	GPIOx_LCKR_OFFSET		0x1C
-#define	GPIOx_AFRL_OFFSET		0x20
-#define	GPIOx_AFRH_OFFSET		0x24
-
+enum
+{
+    GPIOx_MODER_OFFSET = 0x00,
+    GPIOx_OTYPER_OFFSET = 0x04,
+    GPIOx_OSPEEDR_OFFSET = 0x08,
+    GPIOx_PUPDR_OFFSET = 0x0C,
+    GPIOx_IDR_OFFSET = 0x10,
+    GPIOx_ODR_OFFSET = 0x14,
+    GPIOx_BSRR_OFFSET = 0x18,
+    GPIOx_LCKR_OFFSET = 0x1C,
+    GPIOx_AFRL_OFFSET = 0x20,
+    GPIOx_AFRH_OFFSET = 0x24
+};

 /* SPI section */
-#define	SPIx_CR1_OFFSET		0x00
-#define	SPIx_CR2_OFFSET		0x04
-#define	SPIx_SR_OFFSET		0x08
-#define	SPIx_DR_OFFSET		0x0C
-#define	SPIx_CRCPR_OFFSET	0x10
-#define	SPIx_RXCRCR_OFFSET	0x14
-#define	SPIx_TXCRCR_OFFSET	0x18
-
+enum
+{
+    SPIx_CR1_OFFSET = 0x00,
+    SPIx_CR2_OFFSET = 0x04,
+    SPIx_SR_OFFSET = 0x08,
+    SPIx_DR_OFFSET = 0x0C,
+    SPIx_CRCPR_OFFSET = 0x10,
+    SPIx_RXCRCR_OFFSET = 0x14,
+    SPIx_TXCRCR_OFFSET = 0x18
+};

 /* UART section */
-#define	USARTx_SR_OFFSET		0x00
-#define	USARTx_DR_OFFSET		0x04
-#define	USARTx_BRR_OFFSET		0x08
-#define	USARTx_CR1_OFFSET		0x0C
-#define	USARTx_CR2_OFFSET		0x10
-#define	USARTx_CR3_OFFSET		0x14
-#define	USARTx_GTPR_OFFSET		0x18
-
+enum
+{
+    USARTx_SR_OFFSET = 0x00,
+    USARTx_DR_OFFSET = 0x04,
+    USARTx_BRR_OFFSET = 0x08,
+    USARTx_CR1_OFFSET = 0x0C,
+    USARTx_CR2_OFFSET = 0x10,
+    USARTx_CR3_OFFSET = 0x14,
+    USARTx_GTPR_OFFSET = 0x18,
+};

 /* I2C section */
-#define	I2Cx_CR1_OFFSET			0x00
-#define	I2Cx_CR2_OFFSET			0x04
-#define	I2Cx_OAR1_OFFSET		0x08
-#define	I2Cx_OAR2_OFFSET		0x0C
-#define	I2Cx_DR_OFFSET			0x10
-#define	I2Cx_SR1_OFFSET			0x14
-#define	I2Cx_SR2_OFFSET			0x18
-#define	I2Cx_CCR_OFFSET			0x1C
-#define	I2Cx_TRISE_OFFSET		0x20
-
+enum
+{
+    I2Cx_CR1_OFFSET = 0x00,
+    I2Cx_CR2_OFFSET = 0x04,
+    I2Cx_OAR1_OFFSET = 0x08,
+    I2Cx_OAR2_OFFSET = 0x0C,
+    I2Cx_DR_OFFSET = 0x10,
+    I2Cx_SR1_OFFSET = 0x14,
+    I2Cx_SR2_OFFSET = 0x18,
+    I2Cx_CCR_OFFSET = 0x1C,
+    I2Cx_TRISE_OFFSET = 0x20,
+};

 /* TIM section */
-#define	TIMx_CR1_OFFSET			0x00
-#define	TIMx_CR2_OFFSET			0x04
-#define	TIMx_SMCR_OFFSET		0x08
-#define	TIMx_DIER_OFFSET		0x0C
-#define	TIMx_SR_OFFSET			0x10
-#define	TIMx_EGR_OFFSET			0x14
-#define	TIMx_CCMR1_OFFSET		0x18
-#define	TIMx_CCMR2_OFFSET		0x1C
-#define	TIMx_CCER_OFFSET		0x20
-#define	TIMx_CNT_OFFSET			0x24
-#define	TIMx_PSC_OFFSET			0x28
-#define	TIMx_ARR_OFFSET			0x2C
-#define	TIMx_CCR1_OFFSET		0x34
-#define	TIMx_CCR2_OFFSET		0x38
-#define	TIMx_CCR3_OFFSET		0x3C
-#define	TIMx_CCR4_OFFSET		0x40
-#define	TIMx_BDTR_OFFSET		0x44
-#define	TIMx_DCR_OFFSET			0x48
-#define	TIMx_DMAR_OFFSET		0x4C
-#define	TIMx_OR_OFFSET			0x50
+enum
+{
+    TIMx_CR1_OFFSET = 0x00,
+    TIMx_CR2_OFFSET = 0x04,
+    TIMx_SMCR_OFFSET = 0x08,
+    TIMx_DIER_OFFSET = 0x0C,
+    TIMx_SR_OFFSET = 0x10,
+    TIMx_EGR_OFFSET = 0x14,
+    TIMx_CCMR1_OFFSET = 0x18,
+    TIMx_CCMR2_OFFSET = 0x1C,
+    TIMx_CCER_OFFSET = 0x20,
+    TIMx_CNT_OFFSET = 0x24,
+    TIMx_PSC_OFFSET = 0x28,
+    TIMx_ARR_OFFSET = 0x2C,
+    TIMx_CCR1_OFFSET = 0x34,
+    TIMx_CCR2_OFFSET = 0x38,
+    TIMx_CCR3_OFFSET = 0x3C,
+    TIMx_CCR4_OFFSET = 0x40,
+    TIMx_BDTR_OFFSET = 0x44,
+    TIMx_DCR_OFFSET = 0x48,
+    TIMx_DMAR_OFFSET = 0x4C,
+    TIMx_OR_OFFSET = 0x50
+};

 /* ADC section */
-#define	ADC1_OFFSET				0x000
-#define	ADC2_OFFSET				0x100
-#define	ADC3_OFFSET				0x200
-
-#define	ADCx_SR_OFFSET			0x00
-#define	ADCx_CR1_OFFSET			0x04
-#define	ADCx_CR2_OFFSET			0x08
-#define	ADCx_SMPR1_OFFSET		0x0C
-#define	ADCx_SMPR2_OFFSET		0x10
-#define	ADCx_JOFR1_OFFSET		0x14
-#define	ADCx_JOFR2_OFFSET		0x18
-#define	ADCx_JOFR3_OFFSET		0x1C
-#define	ADCx_JOFR4_OFFSET		0x20
-#define	ADCx_HTR_OFFSET			0x24
-#define	ADCx_LTR_OFFSET			0x28
-#define	ADCx_SQR1_OFFSET		0x2C
-#define	ADCx_SQR2_OFFSET		0x30
-#define	ADCx_SQR3_OFFSET		0x34
-#define	ADCx_JSQR_OFFSET		0x38
-#define	ADCx_JDR1_OFFSET		0x3C
-#define	ADCx_JDR2_OFFSET		0x40
-#define	ADCx_JDR3_OFFSET		0x44
-#define	ADCx_JDR4_OFFSET		0x48
-#define	ADCx_DR_OFFSET			0x4C
-
-#define	ADC_CSR_OFFSET			0x300
-#define	ADC_CCR_OFFSET			0x304
-#define	ADC_CDR_OFFSET			0x308
-
+enum
+{
+    ADC1_OFFSET = 0x000,
+    ADC2_OFFSET = 0x100,
+    ADC3_OFFSET = 0x200,
+
+    ADCx_SR_OFFSET = 0x00,
+    ADCx_CR1_OFFSET = 0x04,
+    ADCx_CR2_OFFSET = 0x08,
+    ADCx_SMPR1_OFFSET = 0x0C,
+    ADCx_SMPR2_OFFSET = 0x10,
+    ADCx_JOFR1_OFFSET = 0x14,
+    ADCx_JOFR2_OFFSET = 0x18,
+    ADCx_JOFR3_OFFSET = 0x1C,
+    ADCx_JOFR4_OFFSET = 0x20,
+    ADCx_HTR_OFFSET = 0x24,
+    ADCx_LTR_OFFSET = 0x28,
+    ADCx_SQR1_OFFSET = 0x2C,
+    ADCx_SQR2_OFFSET = 0x30,
+    ADCx_SQR3_OFFSET = 0x34,
+    ADCx_JSQR_OFFSET = 0x38,
+    ADCx_JDR1_OFFSET = 0x3C,
+    ADCx_JDR2_OFFSET = 0x40,
+    ADCx_JDR3_OFFSET = 0x44,
+    ADCx_JDR4_OFFSET = 0x48,
+    ADCx_DR_OFFSET = 0x4C,
+
+    ADC_CSR_OFFSET = 0x300,
+    ADC_CCR_OFFSET = 0x304,
+    ADC_CDR_OFFSET = 0x308,
+};

 /* SYSCFG section */
-#define	SYSCFG_MEMRM_OFFSET			0x00
-#define	SYSCFG_PMC_OFFSET			0x04
-#define	SYSCFG_EXTICR1_OFFSET		0x08
-#define	SYSCFG_EXTICR2_OFFSET		0x0C
-#define	SYSCFG_EXTICR3_OFFSET		0x10
-#define	SYSCFG_EXTICR4_OFFSET		0x14
-#define	SYSCFG_CMPCR_OFFSET			0x20
-
+enum
+{
+    SYSCFG_MEMRM_OFFSET = 0x00,
+    SYSCFG_PMC_OFFSET = 0x04,
+    SYSCFG_EXTICR1_OFFSET = 0x08,
+    SYSCFG_EXTICR2_OFFSET = 0x0C,
+    SYSCFG_EXTICR3_OFFSET = 0x10,
+    SYSCFG_EXTICR4_OFFSET = 0x14,
+    SYSCFG_CMPCR_OFFSET = 0x20,
+};

 /* PWR section */
-#define	PWR_CR_OFFSET				0x00
-#define	PWR_CSR_OFFSET				0x04
+enum
+{
+    PWR_CR_OFFSET = 0x00,
+    PWR_CSR_OFFSET = 0x04,
+};

 /* EXTI section */
-#define	EXTI_IMR_OFFSET				0x00
-#define	EXTI_EMR_OFFSET				0x04
-#define	EXTI_RTSR_OFFSET			0x08
-#define	EXTI_FTSR_OFFSET			0x0C
-#define	EXTI_SWIER_OFFSET			0x10
-#define	EXTI_PR_OFFSET				0x14
-
+enum
+{
+    EXTI_IMR_OFFSET = 0x00,
+    EXTI_EMR_OFFSET = 0x04,
+    EXTI_RTSR_OFFSET = 0x08,
+    EXTI_FTSR_OFFSET = 0x0C,
+    EXTI_SWIER_OFFSET = 0x10,
+    EXTI_PR_OFFSET = 0x14,
+};

 /* DMA section */
-#define	DMAx_LISR_OFFSET		0x0000
-#define	DMAx_HISR_OFFSET		0x0004
-#define	DMAx_LIFCR_OFFSET		0x0008
-#define	DMAx_HIFCR_OFFSET		0x000C
-#define	DMAx_S0CR_OFFSET		0x0010
-#define	DMAx_S0NDTR_OFFSET		0x0014
-#define	DMAx_S0PAR_OFFSET		0x0018
-#define	DMAx_S0M0AR_OFFSET		0x001C
-#define	DMAx_S0M1AR_OFFSET		0x0020
-#define	DMAx_S0FCR_OFFSET		0x0024
-
-#define	DMAx_STREAM_OFFSET		0x18
-
+enum
+{
+    DMAx_LISR_OFFSET = 0x0000,
+    DMAx_HISR_OFFSET = 0x0004,
+    DMAx_LIFCR_OFFSET = 0x0008,
+    DMAx_HIFCR_OFFSET = 0x000C,
+    DMAx_S0CR_OFFSET = 0x0010,
+    DMAx_S0NDTR_OFFSET = 0x0014,
+    DMAx_S0PAR_OFFSET = 0x0018,
+    DMAx_S0M0AR_OFFSET = 0x001C,
+    DMAx_S0M1AR_OFFSET = 0x0020,
+    DMAx_S0FCR_OFFSET = 0x0024,
+
+    DMAx_STREAM_OFFSET = 0x18
+};

 /* CAN section */
-#define	CAN_MCR_OFFSET			0x0000
-#define	CAN_MSR_OFFSET			0x0004
-#define	CAN_TSR_OFFSET			0x0008
-#define	CAN_RF0R_OFFSET			0x000C
-#define	CAN_RF1R_OFFSET			0x0010
-#define	CAN_IER_OFFSET			0x0014
-#define	CAN_ESR_OFFSET			0x0018
-#define	CAN_BTR_OFFSET			0x001C
-
-#define	CAN_TI0R_OFFSET			0x0180
-#define	CAN_TDT0R_OFFSET		0x0184
-#define	CAN_TDL0R_OFFSET		0x0188
-#define	CAN_TDH0R_OFFSET		0x018C
-
-#define	CAN_TIxR_OFFSET			0x10
-
-#define	CAN_TI1R_OFFSET			0x0190
-#define	CAN_TDT1R_OFFSET		0x0194
-#define	CAN_TDL1R_OFFSET		0x0198
-#define	CAN_TDH1R_OFFSET		0x019C
-#define	CAN_TI2R_OFFSET			0x01A0
-#define	CAN_TDT2R_OFFSET		0x01A4
-#define	CAN_TDL2R_OFFSET		0x01A8
-#define	CAN_TDH2R_OFFSET		0x01AC
-#define	CAN_RI0R_OFFSET			0x01B0
-#define	CAN_RDT0R_OFFSET		0x01B4
-#define	CAN_RDL0R_OFFSET		0x01B8
-#define	CAN_RDH0R_OFFSET		0x01BC
-
-#define	CAN_RIxR_OFFSET			0x10
-
-#define	CAN_RI1R_OFFSET			0x01C0
-#define	CAN_RDT1R_OFFSET		0x01C4
-#define	CAN_RDL1R_OFFSET		0x01C8
-#define	CAN_RDH1R_OFFSET		0x01CC
-
-#define	CAN_FMR_OFFSET			0x0200
-#define	CAN_FM1R_OFFSET			0x0204
-#define	CAN_FS1R_OFFSET			0x020C
-#define	CAN_FFA1R_OFFSET		0x0214
-#define	CAN_FA1R_OFFSET			0x021C
-#define	CAN_F0R1_OFFSET			0x0240
-#define	CAN_F0R2_OFFSET			0x0244
-#define	CAN_FORx_OFFSET			0x8
-
-
-#define	ETHMAC_MACCR_OFFSET			0x0000
-#define	ETHMAC_MACFFR_OFFSET		0x0004
-#define	ETHMAC_MACHTHR_OFFSET		0x0008
-#define	ETHMAC_MACHTLR_OFFSET		0x000C
-#define	ETHMAC_MACMIIAR_OFFSET		0x0010
-#define	ETHMAC_MACMIIDR_OFFSET		0x0014
-#define	ETHMAC_MACFCR_OFFSET		0x0018
-#define	ETHMAC_MACVLANTR_OFFSET		0x001C
-#define	ETHMAC_MACRWUFFR_OFFSET		0x0028
-#define	ETHMAC_MACPMTCSR_OFFSET		0x002C
-
-#define	ETHMAC_MACDBGR_OFFSET		0x0034
-#define	ETHMAC_MACSR_OFFSET			0x0038
-#define	ETHMAC_MACIMR_OFFSET		0x003C
-#define	ETHMAC_MACA0HR_OFFSET		0x0040
-#define	ETHMAC_MACA0LR_OFFSET		0x0044
-#define	ETHMAC_MACA1HR_OFFSET		0x0048
-#define	ETHMAC_MACA1LR_OFFSET		0x004C
-#define	ETHMAC_MACA2HR_OFFSET		0x0050
-#define	ETHMAC_MACA2LR_OFFSET		0x0054
-#define	ETHMAC_MACA3HR_OFFSET		0x0058
-#define	ETHMAC_MACA3LR_OFFSET		0x005C
-#define	ETHMAC_MMCCR_OFFSET			0x0100
-#define	ETHMAC_MMCRIR_OFFSET		0x0104
-#define	ETHMAC_MMCTIR_OFFSET		0x0108
-#define	ETHMAC_MMCRIMR_OFFSET		0x010C
-#define	ETHMAC_MMCTIMR_OFFSET		0x0110
-#define	ETHMAC_MMCTGFSCCR_OFFSET	0x014C
-#define	ETHMAC_MMCTGFMSCCR_OFFSET	0x0150
-
-
-
-#define	ETHMAC_MMCTGFCR_OFFSET		0x0168
-#define	ETHMAC_MMCRFCER_OFFSET		0x0194
-#define	ETHMAC_MMCRFAECR_OFFSET		0x0198
-#define	ETHMAC_MMCRGUFCR_OFFSET		0x01C4
-#define	ETHMAC_PTPTSCR_OFFSET		0x0700
-#define	ETHMAC_PTPSSIR_OFFSET		0x0704
-#define	ETHMAC_PTPTSHR_OFFSET		0x0708
-#define	ETHMAC_PTPTSLR_OFFSET		0x070C
-#define	ETHMAC_PTPTSHUR_OFFSET		0x0710
-#define	ETHMAC_PTPTSLUR_OFFSET		0x0714
-#define	ETHMAC_PTPTSAR_OFFSET		0x0718
-#define	ETHMAC_PTPTTHR_OFFSET		0x071C
-#define	ETHMAC_PTPTTLR_OFFSET		0x0720
-#define	ETHMAC_PTPTSSR_OFFSET		0x0728
-#define	ETHMAC_DMABMR_OFFSET		0x1000
-#define	ETHMAC_DMATPDR_OFFSET		0x1004
-#define	ETHMAC_DMARPDR_OFFSET		0x1008
-#define	ETHMAC_DMARDLAR_OFFSET		0x100C
-#define	ETHMAC_DMATDLAR_OFFSET		0x1010
-#define	ETHMAC_DMASR_OFFSET			0x1014
-
-#define	ETHMAC_DMAOMR_OFFSET		0x1018
-#define	ETHMAC_DMAIER_OFFSET		0x101C
-#define	ETHMAC_DMAMFBOCR_OFFSET		0x1020
-#define	ETHMAC_DMARSWTR_OFFSET		0x1024
-#define	ETHMAC_DMACHTDR_OFFSET		0x1048
-#define	ETHMAC_DMACHRDR_OFFSET		0x104C
-#define	ETHMAC_DMACHTBAR_OFFSET		0x1050
-#define	ETHMAC_DMACHRBAR_OFFSET		0x1054
+enum
+{
+    CAN_MCR_OFFSET = 0x0000,
+    CAN_MSR_OFFSET = 0x0004,
+    CAN_TSR_OFFSET = 0x0008,
+    CAN_RF0R_OFFSET = 0x000C,
+    CAN_RF1R_OFFSET = 0x0010,
+    CAN_IER_OFFSET = 0x0014,
+    CAN_ESR_OFFSET = 0x0018,
+    CAN_BTR_OFFSET = 0x001C,
+
+    CAN_TI0R_OFFSET = 0x0180,
+    CAN_TDT0R_OFFSET = 0x0184,
+    CAN_TDL0R_OFFSET = 0x0188,
+    CAN_TDH0R_OFFSET = 0x018C,
+
+    CAN_TIxR_OFFSET = 0x10,
+
+    CAN_TI1R_OFFSET = 0x0190,
+    CAN_TDT1R_OFFSET = 0x0194,
+    CAN_TDL1R_OFFSET = 0x0198,
+    CAN_TDH1R_OFFSET = 0x019C,
+    CAN_TI2R_OFFSET = 0x01A0,
+    CAN_TDT2R_OFFSET = 0x01A4,
+    CAN_TDL2R_OFFSET = 0x01A8,
+    CAN_TDH2R_OFFSET = 0x01AC,
+    CAN_RI0R_OFFSET = 0x01B0,
+    CAN_RDT0R_OFFSET = 0x01B4,
+    CAN_RDL0R_OFFSET = 0x01B8,
+    CAN_RDH0R_OFFSET = 0x01BC,
+
+    CAN_RIxR_OFFSET = 0x10,
+
+    CAN_RI1R_OFFSET = 0x01C0,
+    CAN_RDT1R_OFFSET = 0x01C4,
+    CAN_RDL1R_OFFSET = 0x01C8,
+    CAN_RDH1R_OFFSET = 0x01CC,
+
+    CAN_FMR_OFFSET = 0x0200,
+    CAN_FM1R_OFFSET = 0x0204,
+    CAN_FS1R_OFFSET = 0x020C,
+    CAN_FFA1R_OFFSET = 0x0214,
+    CAN_FA1R_OFFSET = 0x021C,
+    CAN_F0R1_OFFSET = 0x0240,
+    CAN_F0R2_OFFSET = 0x0244,
+    CAN_FORx_OFFSET = 0x8
+};
+
+enum
+{
+    ETHMAC_MACCR_OFFSET = 0x0000,
+    ETHMAC_MACFFR_OFFSET = 0x0004,
+    ETHMAC_MACHTHR_OFFSET = 0x0008,
+    ETHMAC_MACHTLR_OFFSET = 0x000C,
+    ETHMAC_MACMIIAR_OFFSET = 0x0010,
+    ETHMAC_MACMIIDR_OFFSET = 0x0014,
+    ETHMAC_MACFCR_OFFSET = 0x0018,
+    ETHMAC_MACVLANTR_OFFSET = 0x001C,
+    ETHMAC_MACRWUFFR_OFFSET = 0x0028,
+    ETHMAC_MACPMTCSR_OFFSET = 0x002C,
+
+    ETHMAC_MACDBGR_OFFSET = 0x0034,
+    ETHMAC_MACSR_OFFSET = 0x0038,
+    ETHMAC_MACIMR_OFFSET = 0x003C,
+    ETHMAC_MACA0HR_OFFSET = 0x0040,
+    ETHMAC_MACA0LR_OFFSET = 0x0044,
+    ETHMAC_MACA1HR_OFFSET = 0x0048,
+    ETHMAC_MACA1LR_OFFSET = 0x004C,
+    ETHMAC_MACA2HR_OFFSET = 0x0050,
+    ETHMAC_MACA2LR_OFFSET = 0x0054,
+    ETHMAC_MACA3HR_OFFSET = 0x0058,
+    ETHMAC_MACA3LR_OFFSET = 0x005C,
+    ETHMAC_MMCCR_OFFSET = 0x0100,
+    ETHMAC_MMCRIR_OFFSET = 0x0104,
+    ETHMAC_MMCTIR_OFFSET = 0x0108,
+    ETHMAC_MMCRIMR_OFFSET = 0x010C,
+    ETHMAC_MMCTIMR_OFFSET = 0x0110,
+    ETHMAC_MMCTGFSCCR_OFFSET = 0x014C,
+    ETHMAC_MMCTGFMSCCR_OFFSET = 0x0150,
+
+
+
+    ETHMAC_MMCTGFCR_OFFSET = 0x0168,
+    ETHMAC_MMCRFCER_OFFSET = 0x0194,
+    ETHMAC_MMCRFAECR_OFFSET = 0x0198,
+    ETHMAC_MMCRGUFCR_OFFSET = 0x01C4,
+    ETHMAC_PTPTSCR_OFFSET = 0x0700,
+    ETHMAC_PTPSSIR_OFFSET = 0x0704,
+    ETHMAC_PTPTSHR_OFFSET = 0x0708,
+    ETHMAC_PTPTSLR_OFFSET = 0x070C,
+    ETHMAC_PTPTSHUR_OFFSET = 0x0710,
+    ETHMAC_PTPTSLUR_OFFSET = 0x0714,
+    ETHMAC_PTPTSAR_OFFSET = 0x0718,
+    ETHMAC_PTPTTHR_OFFSET = 0x071C,
+    ETHMAC_PTPTTLR_OFFSET = 0x0720,
+    ETHMAC_PTPTSSR_OFFSET = 0x0728,
+    ETHMAC_DMABMR_OFFSET = 0x1000,
+    ETHMAC_DMATPDR_OFFSET = 0x1004,
+    ETHMAC_DMARPDR_OFFSET = 0x1008,
+    ETHMAC_DMARDLAR_OFFSET = 0x100C,
+    ETHMAC_DMATDLAR_OFFSET = 0x1010,
+    ETHMAC_DMASR_OFFSET = 0x1014,
+
+    ETHMAC_DMAOMR_OFFSET = 0x1018,
+    ETHMAC_DMAIER_OFFSET = 0x101C,
+    ETHMAC_DMAMFBOCR_OFFSET = 0x1020,
+    ETHMAC_DMARSWTR_OFFSET = 0x1024,
+    ETHMAC_DMACHTDR_OFFSET = 0x1048,
+    ETHMAC_DMACHRDR_OFFSET = 0x104C,
+    ETHMAC_DMACHTBAR_OFFSET = 0x1050,
+    ETHMAC_DMACHRBAR_OFFSET = 0x1054,
+};

 // Debug
-#define	DBGMCU_APB1_FZ		0xE0042008
-#define	DBGMCU_APB2_FZ		0xE004200C
+enum
+{
+    DBGMCU_APB1_FZ = 0xE0042008,
+    DBGMCU_APB2_FZ = 0xE004200C
+};

 /* Unique 96bit ID section */
 #define UNIQUE_ID_BASE_ADDRESS  0x1FFF7A10

 /* CRC Offsets */
-#define	CRC_DR_OFFSET		0x00
-#define	CRC_IDR_OFFSET		0x04
-#define	CRC_CR_OFFSET		0x08
-
+enum
+{
+    CRC_DR_OFFSET = 0x00,
+    CRC_IDR_OFFSET = 0x04,
+    CRC_CR_OFFSET = 0x08,
+};

 /* Independent Watchdog Offsets */
-#define	IWDG_KR_OFFSET		0x00
-#define	IWDG_PR_OFFSET		0x04
-#define	IWDG_RLR_OFFSET		0x08
-#define	IWDG_SR_OFFSET		0x0C
-
+enum
+{
+    IWDG_KR_OFFSET = 0x00,
+    IWDG_PR_OFFSET = 0x04,
+    IWDG_RLR_OFFSET = 0x08,
+    IWDG_SR_OFFSET = 0x0C,
+};

 #endif /* MEMMAP_H_ */
diff --git a/drivers/stm32f4xx/stm32f4xx.c b/drivers/stm32f4xx/stm32f4xx.c
index d736d6c..c6fbbb9 100644
--- a/drivers/stm32f4xx/stm32f4xx.c
+++ b/drivers/stm32f4xx/stm32f4xx.c
@@ -47,22 +47,46 @@ I2C_INIT(_i2c2, I2C2_BASE_ADDRESS, RCC_APB_BUS_I2C2, RCC_APB_BIT_I2C2,
         NVIC_IRQ_LINE_I2C2_EV, NVIC_IRQ_LINE_I2C2_ER);

 /* Real SPIs */
-SPI_INIT(_spi1, SPI1_BASE_ADDRESS, RCC_APB_BUS_SPI1, RCC_APB_BIT_SPI1, NVIC_IRQ_LINE_SPI1);
-SPI_INIT(_spi2, SPI2_BASE_ADDRESS, RCC_APB_BUS_SPI2, RCC_APB_BIT_SPI2, NVIC_IRQ_LINE_SPI2);
-SPI_INIT(_spi3, SPI3_BASE_ADDRESS, RCC_APB_BUS_SPI3, RCC_APB_BIT_SPI3, NVIC_IRQ_LINE_SPI3);
+SPI_INIT(_spi1, SPI1_BASE_ADDRESS, RCC_APB_BUS_SPI1, RCC_APB_BIT_SPI1,
+        NVIC_IRQ_LINE_SPI1);
+SPI_INIT(_spi2, SPI2_BASE_ADDRESS, RCC_APB_BUS_SPI2, RCC_APB_BIT_SPI2,
+        NVIC_IRQ_LINE_SPI2);
+SPI_INIT(_spi3, SPI3_BASE_ADDRESS, RCC_APB_BUS_SPI3, RCC_APB_BIT_SPI3,
+        NVIC_IRQ_LINE_SPI3);

 /* Real Timers */
-//TIMER_INIT(_tim1, TIM1_BASE_ADDRESS, RCC_APB_BUS_TIM1, RCC_APB_BIT_TIM1, NVIC_IRQ_LINE_TIM1_CC, 4);
-TIMER_INIT(_tim1, TIM1_BASE_ADDRESS, RCC_APB_BUS_TIM1, RCC_APB_BIT_TIM1, NVIC_IRQ_LINE_TIM1_UP_TIM10, 4);
-TIMER_INIT(_tim2, TIM2_BASE_ADDRESS, RCC_APB_BUS_TIM2, RCC_APB_BIT_TIM2, NVIC_IRQ_LINE_TIM2, 4);
-TIMER_INIT(_tim3, TIM3_BASE_ADDRESS, RCC_APB_BUS_TIM3, RCC_APB_BIT_TIM3, NVIC_IRQ_LINE_TIM3, 4);
-TIMER_INIT(_tim4, TIM4_BASE_ADDRESS, RCC_APB_BUS_TIM4, RCC_APB_BIT_TIM4, NVIC_IRQ_LINE_TIM4, 4);
-TIMER_INIT(_tim5, TIM5_BASE_ADDRESS, RCC_APB_BUS_TIM5, RCC_APB_BIT_TIM5, NVIC_IRQ_LINE_TIM5, 4);
-
-TIMER_INIT(_tim6, TIM6_BASE_ADDRESS, RCC_APB_BUS_TIM6, RCC_APB_BIT_TIM6, NVIC_IRQ_LINE_TIM6_DAC, 0);
-TIMER_INIT(_tim7, TIM7_BASE_ADDRESS, RCC_APB_BUS_TIM7, RCC_APB_BIT_TIM7, NVIC_IRQ_LINE_TIM7, 0);
-
-TIMER_INIT(_tim8, TIM8_BASE_ADDRESS, RCC_APB_BUS_TIM8, RCC_APB_BIT_TIM8, NVIC_IRQ_LINE_TIM8_CC, 4);
+TIMER_INIT(_tim1, TIM1_BASE_ADDRESS, RCC_APB_BUS_TIM1, RCC_APB_BIT_TIM1,
+        NVIC_IRQ_LINE_TIM1_CC, 4);
+TIMER_INIT(_tim2, TIM2_BASE_ADDRESS, RCC_APB_BUS_TIM2, RCC_APB_BIT_TIM2,
+        NVIC_IRQ_LINE_TIM2, 4);
+TIMER_INIT(_tim3, TIM3_BASE_ADDRESS, RCC_APB_BUS_TIM3, RCC_APB_BIT_TIM3,
+        NVIC_IRQ_LINE_TIM3, 4);
+TIMER_INIT(_tim4, TIM4_BASE_ADDRESS, RCC_APB_BUS_TIM4, RCC_APB_BIT_TIM4,
+        NVIC_IRQ_LINE_TIM4, 4);
+TIMER_INIT(_tim5, TIM5_BASE_ADDRESS, RCC_APB_BUS_TIM5, RCC_APB_BIT_TIM5,
+        NVIC_IRQ_LINE_TIM5, 4);
+
+TIMER_INIT(_tim6, TIM6_BASE_ADDRESS, RCC_APB_BUS_TIM6, RCC_APB_BIT_TIM6,
+        NVIC_IRQ_LINE_TIM6_DAC, 0);
+TIMER_INIT(_tim7, TIM7_BASE_ADDRESS, RCC_APB_BUS_TIM7, RCC_APB_BIT_TIM7,
+        NVIC_IRQ_LINE_TIM7, 0);
+
+TIMER_INIT(_tim8, TIM8_BASE_ADDRESS, RCC_APB_BUS_TIM8, RCC_APB_BIT_TIM8,
+        NVIC_IRQ_LINE_TIM8_CC, 4);
+
+TIMER_INIT(_tim9, TIM9_BASE_ADDRESS, RCC_APB_BUS_TIM9, RCC_APB_BIT_TIM9,
+        NVIC_IRQ_LINE_TIM1_BRK_TIM9, 2);
+TIMER_INIT(_tim10, TIM10_BASE_ADDRESS, RCC_APB_BUS_TIM10, RCC_APB_BIT_TIM10,
+        NVIC_IRQ_LINE_TIM1_UP_TIM10, 1);
+TIMER_INIT(_tim11, TIM11_BASE_ADDRESS, RCC_APB_BUS_TIM11, RCC_APB_BIT_TIM11,
+        NVIC_IRQ_LINE_TIM1_TRG_COM_TIM11, 1);
+
+TIMER_INIT(_tim12, TIM12_BASE_ADDRESS, RCC_APB_BUS_TIM12, RCC_APB_BIT_TIM12,
+        NVIC_IRQ_LINE_TIM8_BRK_TIM12, 2);
+TIMER_INIT(_tim13, TIM13_BASE_ADDRESS, RCC_APB_BUS_TIM13, RCC_APB_BIT_TIM13,
+        NVIC_IRQ_LINE_TIM8_UP_TIM13, 1);
+TIMER_INIT(_tim14, TIM14_BASE_ADDRESS, RCC_APB_BUS_TIM14, RCC_APB_BIT_TIM14,
+        NVIC_IRQ_LINE_TIM8_TRG_COM_TIM14, 1);

 /* Real UARTs */
 UART_INIT(_uart1, USART1_BASE_ADDRESS, RCC_APB_BUS_USART1,
@@ -77,22 +101,45 @@ UART_INIT(_uart5, UART5_BASE_ADDRESS, RCC_APB_BUS_UART5,
         RCC_APB_BIT_UART5, NVIC_IRQ_LINE_UART5);

 /* DMA STREAMS */
-DMA_INIT(_dma1_str0, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 0, NVIC_IRQ_LINE_DMA1_STR0);
-DMA_INIT(_dma1_str1, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 1, NVIC_IRQ_LINE_DMA1_STR1);
-DMA_INIT(_dma1_str2, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 2, NVIC_IRQ_LINE_DMA1_STR2);
-DMA_INIT(_dma1_str3, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 3, NVIC_IRQ_LINE_DMA1_STR3);
-DMA_INIT(_dma1_str4, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 4, NVIC_IRQ_LINE_DMA1_STR4);
-DMA_INIT(_dma1_str5, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 5, NVIC_IRQ_LINE_DMA1_STR5);
-DMA_INIT(_dma1_str6, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 6, NVIC_IRQ_LINE_DMA1_STR6);
-DMA_INIT(_dma1_str7, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 7, NVIC_IRQ_LINE_DMA1_STR7);
-DMA_INIT(_dma2_str0, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 0, NVIC_IRQ_LINE_DMA2_STR0);
-DMA_INIT(_dma2_str1, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 1, NVIC_IRQ_LINE_DMA2_STR1);
-DMA_INIT(_dma2_str2, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 2, NVIC_IRQ_LINE_DMA2_STR2);
-DMA_INIT(_dma2_str3, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 3, NVIC_IRQ_LINE_DMA2_STR3);
-DMA_INIT(_dma2_str4, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 4, NVIC_IRQ_LINE_DMA2_STR4);
-DMA_INIT(_dma2_str5, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 5, NVIC_IRQ_LINE_DMA2_STR5);
-DMA_INIT(_dma2_str6, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 6, NVIC_IRQ_LINE_DMA2_STR6);
-DMA_INIT(_dma2_str7, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 7, NVIC_IRQ_LINE_DMA2_STR7);
+DMA_INIT(_dma1_str0, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 0,
+        NVIC_IRQ_LINE_DMA1_STR0);
+DMA_INIT(_dma1_str1, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 1,
+        NVIC_IRQ_LINE_DMA1_STR1);
+DMA_INIT(_dma1_str2, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 2,
+        NVIC_IRQ_LINE_DMA1_STR2);
+DMA_INIT(_dma1_str3, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 3,
+        NVIC_IRQ_LINE_DMA1_STR3);
+DMA_INIT(_dma1_str4, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 4,
+        NVIC_IRQ_LINE_DMA1_STR4);
+DMA_INIT(_dma1_str5, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 5,
+        NVIC_IRQ_LINE_DMA1_STR5);
+DMA_INIT(_dma1_str6, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 6,
+        NVIC_IRQ_LINE_DMA1_STR6);
+DMA_INIT(_dma1_str7, DMA1_BASE_ADDRESS, RCC_AHB_BIT_DMA1, 7,
+        NVIC_IRQ_LINE_DMA1_STR7);
+DMA_INIT(_dma2_str0, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 0,
+        NVIC_IRQ_LINE_DMA2_STR0);
+DMA_INIT(_dma2_str1, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 1,
+        NVIC_IRQ_LINE_DMA2_STR1);
+DMA_INIT(_dma2_str2, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 2,
+        NVIC_IRQ_LINE_DMA2_STR2);
+DMA_INIT(_dma2_str3, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 3,
+        NVIC_IRQ_LINE_DMA2_STR3);
+DMA_INIT(_dma2_str4, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 4,
+        NVIC_IRQ_LINE_DMA2_STR4);
+DMA_INIT(_dma2_str5, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 5,
+        NVIC_IRQ_LINE_DMA2_STR5);
+DMA_INIT(_dma2_str6, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 6,
+        NVIC_IRQ_LINE_DMA2_STR6);
+DMA_INIT(_dma2_str7, DMA2_BASE_ADDRESS, RCC_AHB_BIT_DMA2, 7,
+        NVIC_IRQ_LINE_DMA2_STR7);
+
+CAN_INIT(_can1, CAN1_BASE_ADDRESS, RCC_APB_BUS_CAN1, RCC_APB_BIT_CAN1,
+        NVIC_IRQ_LINE_CAN1_TX, NVIC_IRQ_LINE_CAN1_RX0, NVIC_IRQ_LINE_CAN1_RX1,
+        NVIC_IRQ_LINE_CAN1_SCE);
+CAN_INIT(_can2, CAN2_BASE_ADDRESS, RCC_APB_BUS_CAN2, RCC_APB_BIT_CAN2,
+        NVIC_IRQ_LINE_CAN2_TX, NVIC_IRQ_LINE_CAN2_RX0, NVIC_IRQ_LINE_CAN2_RX1,
+        NVIC_IRQ_LINE_CAN2_SCE);

 /* Definitions for user access */
 const gpio_t gpioA = GPIO_A;
diff --git a/drivers/stm32f4xx/stm32f4xx.h b/drivers/stm32f4xx/stm32f4xx.h
index 6a45313..b215588 100644
--- a/drivers/stm32f4xx/stm32f4xx.h
+++ b/drivers/stm32f4xx/stm32f4xx.h
@@ -33,6 +33,7 @@
 #include "i2c_.h"
 #include "spi_.h"
 #include "dma_str.h"
+#include "can_.h"

 extern const _gpio_t _gpioA, _gpioB, _gpioC, _gpioD, _gpioE, _gpioF, _gpioG,
         _gpioH, _gpioI;
@@ -63,6 +64,7 @@ extern const _uart_t _uart1, _uart2, _uart3, _uart4, _uart5;
 #define UART_5 (&_uart5)

 extern const _timer_t _tim1, _tim2, _tim3, _tim4, _tim5, _tim6, _tim7, _tim8;
+extern const _timer_t _tim9, _tim10, _tim11, _tim12, _tim13, _tim14;
 #define TIM_1 (&_tim1)
 #define TIM_2 (&_tim2)
 #define TIM_3 (&_tim3)
@@ -71,11 +73,18 @@ extern const _timer_t _tim1, _tim2, _tim3, _tim4, _tim5, _tim6, _tim7, _tim8;
 #define TIM_6 (&_tim6)
 #define TIM_7 (&_tim7)
 #define TIM_8 (&_tim8)
+#define TIM_9 (&_tim9)
+#define TIM_10 (&_tim10)
+#define TIM_11 (&_tim11)
+#define TIM_12 (&_tim12)
+#define TIM_13 (&_tim13)
+#define TIM_14 (&_tim14)

 extern const _dma_t _dma1_str0, _dma1_str1, _dma1_str2, _dma1_str3, _dma1_str4,
         _dma1_str5, _dma1_str6, _dma1_str7;
 extern const _dma_t _dma2_str0, _dma2_str1, _dma2_str2, _dma2_str3, _dma2_str4,
         _dma2_str5, _dma2_str6, _dma2_str7;
+
 #define DMA1_STR0 (&_dma1_str0)
 #define DMA1_STR1 (&_dma1_str1)
 #define DMA1_STR2 (&_dma1_str2)
@@ -93,4 +102,7 @@ extern const _dma_t _dma2_str0, _dma2_str1, _dma2_str2, _dma2_str3, _dma2_str4,
 #define DMA2_STR6 (&_dma2_str6)
 #define DMA2_STR7 (&_dma2_str7)

+extern const _can_t _can2;
+#define CAN_2 (&_can2)
+
 #endif /* STM32F4XX_H_ */
diff --git a/platform/boreas/boreas_drivers.c b/platform/boreas/boreas_drivers.c
index 6760208..85f5f1c 100644
--- a/platform/boreas/boreas_drivers.c
+++ b/platform/boreas/boreas_drivers.c
@@ -34,6 +34,7 @@
 #include "exti_.h"
 #include "exti.h"
 #include "i2c_.h"
+#include "can_.h"

 /** GPIO Section **/
 static void gpio_drivers_setup();
@@ -55,7 +56,8 @@ static void spi_drivers_setup();
 #define I2C1_CLOCK_MODE	I2C_CLOCK_MODE_FAST
 static void i2c_drivers_setup();

-
+static void can_drivers_setup();
+can_t can = CAN_2;


 void platform_drivers_setup()
@@ -66,6 +68,7 @@ void platform_drivers_setup()

 	i2c_drivers_setup();
 	spi_drivers_setup();
+	can_drivers_setup();
 }

 static void i2c_drivers_setup(){
@@ -225,6 +228,32 @@ void tim2_isr()
     timer_handle_interrupt(TIM_2);
 }

+static void can_drivers_setup()
+{
+    // Configure the CAN PB12/13
+    gpio_set_can_rx(GPIO_B, GPIO_PIN_12);
+    gpio_set_can_tx(GPIO_B, GPIO_PIN_13);
+
+    // Start it
+    can_enable(CAN_2, 1000000);
+}
+
+void can2_tx_isr()
+{
+    can_handle_tx_interrupt(CAN_2);
+}
+void can2_rx0_isr()
+{
+    can_handle_rx0_interrupt(CAN_2);
+}
+void can2_rx1_isr()
+{
+    can_handle_rx1_interrupt(CAN_2);
+}
+void can2_sce_isr()
+{
+    can_handle_sce_interrupt(CAN_2);
+}

 /** External interrupts for RC receiver**/
 void exti0_isr()
